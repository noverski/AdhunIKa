//---- Processing code for Blog-detection camera-tracking ----//

//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
//BlobDetection by v3ga <http://processing.v3ga.net>
//March 2007
//Processing(Beta) v0.85
//
// Adding small boxes on the image process in order to 'close' blobs
//
// ~~~~~~~~~~
// software :
// ~~~~~~~~~~
// - Super Fast Blur v1.1 by Mario Klingemann <http://incubator.quasimondo.com>
// - BlobDetection library
//
// ~~~~~~~~~~
// hardware :
// ~~~~~~~~~~
// - V-Gear webcam       (Input)
// - Arduino O/I Board   (Output)
// - Robotic Arm         (Output)
//=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

import processing.video.*;
import blobDetection.*;
import processing.serial.*;


Capture cam;
BlobDetection theBlobDetection;
PImage img;
boolean newFrame=false;
Serial port;  //must be in global alway. 

boolean DEBUG = true;

int myCurrentBlobsAmount = 0;
// ==================================================
// setup()
// ==================================================
void setup()
{
  // Size of applet
  size(640, 480);
  frameRate(30);
   // Print a list in case COM1 doesn't work out
  println("Available serial ports:");
  // The serial port:

  // List all the available serial ports:
  println(Serial.list());
  // Open whatever port is the one you’re using.
  port = new Serial(this, Serial.list()[3], 9600);  //   /dev/tty.usbserial-A40014iO  - No.4 in the given serial port


  // Capture
  cam = new Capture(this, 160, 120, 15);
  // BlobDetection
  // img which will be sent to detection (a smaller copy of the cam frame);
  img = new PImage(80,60); 
  theBlobDetection = new BlobDetection(img.width, img.height);
  theBlobDetection.setPosDiscrimination(true);
  theBlobDetection.setThreshold(0.2f); // will detect bright areas whose luminosity > 0.2f
}

// ==================================================
// captureEvent()
// ==================================================
void captureEvent(Capture cam)
{
  cam.read();
  newFrame = true;
}


// ==================================================
// draw()
// ==================================================
void draw()
{
  if (newFrame)
  {
    newFrame=false;
    image(cam,0,0,width,height);
    img.copy(cam, 0, 0, cam.width, cam.height, 
    0, 0, img.width, img.height);

    theBlobDetection.computeBlobs(img.pixels);
    drawBlobsAndEdges(true,true);
  }
}

// ==================================================
// drawBlobsAndEdges()
// ==================================================
void drawBlobsAndEdges(boolean drawBlobs, boolean drawEdges)
{
  noFill();
  Blob b;
  EdgeVertex eA,eB;
  myCurrentBlobsAmount = theBlobDetection.getBlobNb();
  if(DEBUG==true) {
  for (int n=0 ; n<myCurrentBlobsAmount; n++)
  {
    b=theBlobDetection.getBlob(n);
    if (b!=null)
    {

      // Blobs
      if (drawBlobs)
      {
        strokeWeight(0);
        stroke(0,0,0);
        fill(255,255,255);		
        rect(
        b.xMin*width,b.yMin*height,
        b.w = 10,b.h = 10                  //change the * to = to create a fixed shape
        );
      }
    }
  }
  }
  DTA();
}

// ==================================================
// Data to Arduino
// ==================================================

void  DTA()
{
  if(myCurrentBlobsAmount<5) {
    port.write('b');
  }
  if(myCurrentBlobsAmount>5 && myCurrentBlobsAmount<20 ) {
    fill(0,255,0);
    ellipse(30,20,55,55);
    port.write('B');
  }         //GREATER THAN
  else {
    fill(255,0,0);
    ellipse(30,20,55,55);
  }
/*  
  if(myCurrentBlobsAmount>20 && myCurrentBlobsAmount<50) {
    port.write('3');
    fill(0,255,0);
    ellipse(130,20,55,55);
  }         //GREATER THAN
  else {
    fill(255,0,0);
    ellipse(130,20,55,55);
  }

  if(myCurrentBlobsAmount>50 && myCurrentBlobsAmount<80) { 
    port.write('4');
    fill(0,255,0);
    ellipse(230,20,55,55);
  }         //GREATER THAN
  else {
    fill(255,0,0);
    ellipse(230,20,55,55);
  }

  if(myCurrentBlobsAmount>80) { 
    port.write('9');
    fill(0,255,0);
    ellipse(330,20,55,55);
  }         //GREATER THAN
  else {
    fill(255,0,0);
    ellipse(330,20,55,55);
  }
*/
}                   

//Arduino Code to control the position of a particular servo motor ;

//Arduino Code
/*Arduino Code
 * Control R\C Servo Motors
 * —————–
 *
 * Controls R\C Servo motor based on the value received
 * from Processing.Org software
 *
 * Code modified by Ajay Varghese
 *
 * Code originally created 1 June 2005
 * copyleft 2005 DojoDave
 * http://arduino.berlios.de
 *
 * based on an orginal by H. Barragan for the Wiring i/o board
 */

int servoPin13 = 13;  // R\C Servo 1 connected to digital pin 13
// int servoPin8 = 8;  // R\C Servo 2 connected to digital pin 8

int pulse = 0;        // Amount to pulse the servo
int counter=0; 
int destination; 
long lastPulse = 0;    // the time in milliseconds of the last pulse
int minPulse = 500;   // Minimum servo position
int maxPulse = 2500;  // Maximum servo position
int refreshTime = 20;  // the time in millisecs needed in between pulses
int val = 0;

//==========================
// Setup
//========================== 

void setup()
{
  pinMode(servoPin13, OUTPUT);   // Set servo pin as an output pin
  //pinMode(servoPin8, OUTPUT);  // Set servo pin as an output pin
  
  pulse = minPulse;           // Set the motor position value to the minimum
  Serial.begin(9600);         // connect to the serial port
} 

//=======================
// Read the Serial
//======================

void loop() 
{  
 
  // read the serial port
  if(Serial.available())
        {
         val = Serial.read();
         }
 
  if (destination<1400){
          pulse=500;
              }else{
                  pulse=1500;
                    }
  counter=0;  
  DTA();


}
  
//======================= 
// Read Data from Serial In
//=======================

void  DTA()
{
  
 // Value "b"
  if (val == 'B') {  
     (destination=2400);{   
      if(counter<destination){
        if (millis() - lastPulse >= refreshTime) {
            digitalWrite(servoPin13, HIGH);   // Turn the motor on
            delayMicroseconds(pulse);       // Length of the pulse sets the motor position
            digitalWrite(servoPin13, LOW);    // Turn the motor off
            lastPulse = millis();           // save the time of the last pulse
             }
         counter++;
                  }
     }
  }
  
  
 // Value "b"
  if (val == 'b') {
     (destination=500);{
      if(counter<destination){
        if (millis() - lastPulse >= refreshTime) {
            digitalWrite(servoPin13, HIGH);   // Turn the motor on
            delayMicroseconds(pulse);       // Length of the pulse sets the motor position
            digitalWrite(servoPin13, LOW);    // Turn the motor off
            lastPulse = millis();           // save the time of the last pulse
             }
        counter++;
      }
     }
  }
  
  
}



